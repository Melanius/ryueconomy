import { Client } from '@notionhq/client';
import { NotionToMarkdown } from 'notion-to-md';
import { cache } from 'react';
import { 
  PageObjectResponse, 
  RichTextItemResponse,
  SelectPropertyItemObjectResponse,
  DatePropertyItemObjectResponse,
  NumberPropertyItemObjectResponse,
  TitlePropertyItemObjectResponse,
  BlockObjectResponse, 
  PartialBlockObjectResponse
} from '@notionhq/client/build/src/api-endpoints';
import { Post } from '@/types/post';
import { CategoryId, NotionPage } from '@/types/notion';
import { notion, databaseId } from './notionClient';
import { notionLog } from './logger';
// 캐시 레이어 import 추가
import { 
  getAllPosts as getCachedPosts,
  getPostBySlug as getCachedPostBySlug,
  getRelatedPosts as getCachedRelatedPosts,
  getCachedBlocks,
  getCachedPageContentAndThumbnail
} from './cache/notion-cache';

// 노션 페이지 속성 타입 정의
interface NotionPageProperties {
  Title: any;
  Excerpt: any;
  Category: any;
  Date: any;
  Views: any;
  Slug: any;
  Featured?: any;
}

// BlogPost는 Post의 확장으로 정의
interface BlogPost extends Post {
  excerpt: string;
  slug: string;
  image: string;
  featured: boolean;
}

/**
 * 노션 카테고리를 블로그 카테고리 형식으로 변환
 */
function mapNotionCategory(notionCategory: string): CategoryId {
  notionLog.info(`Mapping Notion category: ${notionCategory}`);
  
  switch (notionCategory.toLowerCase()) {
    case 'portfolio':
    case 'project':
    case 'work':
    case 'showcase':
    case 'real-portfolio':
      return 'real-portfolio';
      
    case 'code-lab':
    case 'tutorial':
    case 'guide':
    case 'how-to':
    case 'development':
      return 'code-lab';
      
    case 'daily':
    case 'daily-log':
    case 'log':
    case 'diary':
    case 'journal':
      return 'daily-log';
      
    case 'crypto':
    case 'crypto-morning':
    case 'cryptocurrency':
    case 'market':
    case 'trading':
      return 'crypto-morning';
      
    default:
      notionLog.info(`No direct mapping found for category: ${notionCategory}, using default`);
      return 'invest-insight';
  }
}

/**
 * 노션 페이지 객체를 Post 인터페이스로 변환
 */
export function pageToPost(page: PageObjectResponse): BlogPost {
  try {
    notionLog.info(`📘 페이지 변환 시작: ID ${page.id.substring(0, 8)}...`);
    
    // 페이지 속성을 콘솔에 출력 (디버깅)
    notionLog.info(`📘 페이지 속성 목록:`, Object.keys(page.properties).map(key => ({
      key,
      type: (page.properties as any)[key].type
    })));
    
    // 여기서 Notion 페이지의 프로퍼티를 확인하여 필요한 데이터를 추출
    const titleProperty = page.properties.title || page.properties.Title || page.properties.Name;
    let title = 'Untitled';
    
    if (titleProperty?.type === 'title' && titleProperty.title.length > 0) {
      title = titleProperty.title.map(t => t.plain_text).join("").trim();
      // 제목이 빈 문자열인 경우 기본값 사용
      if (title === '') {
        title = `Untitled-${page.id.substring(0, 6)}`;
        notionLog.info(`📘 빈 제목 발견: 기본값으로 대체 "${title}"`);
      }
    } else {
      title = `Untitled-${page.id.substring(0, 6)}`;
      notionLog.info(`📘 제목 속성 없음: 기본값 사용 "${title}"`);
    }
    
    const slugProperty = page.properties.slug || page.properties.Slug;
    let slug = '';
    
    if (slugProperty?.type === 'rich_text' && slugProperty.rich_text.length > 0) {
      slug = slugProperty.rich_text.map(t => t.plain_text).join("").trim();
    }
    
    // 슬러그가 없거나 빈 문자열인 경우 제목에서 생성
    if (!slug) {
      slug = title
        .toLowerCase()
        .replace(/[^\w\s-]/g, '') // 특수문자 제거
        .replace(/\s+/g, '-')     // 공백을 하이픈으로 변경
        .replace(/-+/g, '-');     // 중복 하이픈 제거
      
      // 슬러그가 여전히 비어있다면 ID 사용
      if (!slug || slug === '-') {
        slug = `post-${page.id.substring(0, 8)}`;
      }
      
      notionLog.info(`📘 슬러그 자동 생성: "${title}" → "${slug}"`);
    }
    
    const excerptProperty = page.properties.excerpt || page.properties.Excerpt;
    const excerpt = excerptProperty?.type === 'rich_text' && excerptProperty.rich_text.length > 0
      ? excerptProperty.rich_text.map(t => t.plain_text).join("") 
      : ""; // 발췌문이 없으면 빈 문자열 사용 (기존에는 제목을 사용했음)
    
    const categoryProperty = page.properties.category || page.properties.Category;
    let notionCategory = 'Uncategorized';
    
    if (categoryProperty?.type === 'select' && categoryProperty.select?.name) {
      notionCategory = categoryProperty.select.name;
    }
    
    // 노션 카테고리를 블로그 카테고리로 매핑
    const category = mapNotionCategory(notionCategory);
    
    const dateProperty = page.properties.date || page.properties.Date || page.properties.Published || page.properties['생성 일시'] || page.properties.Created;
    let date = new Date().toISOString().split('T')[0]; // 기본값은 오늘 날짜
    
    if (dateProperty?.type === 'date' && dateProperty.date?.start) {
      date = dateProperty.date.start;
    } else if (page.created_time) {
      // 날짜 속성이 없으면 생성일 사용
      date = new Date(page.created_time).toISOString().split('T')[0];
      notionLog.info(`📘 날짜 속성 없음, 생성일 사용: ${date}`);
    }
    
    // Views 속성 처리 개선 (디버깅)
    const viewsProperty = page.properties.views || page.properties.Views;
    notionLog.info(`📘 조회수 속성 처리:`, viewsProperty ? JSON.stringify(viewsProperty) : 'undefined');
    
    let views = 0;
    if (viewsProperty) {
      if (viewsProperty.type === 'number') {
        views = viewsProperty.number !== null ? viewsProperty.number : 0;
        notionLog.info(`📘 조회수 추출 성공: ${views}`);
      } else {
        notionLog.info(`📘 조회수 속성이 number 타입이 아님: ${viewsProperty.type}`);
      }
    } else {
      notionLog.info(`📘 조회수 속성을 찾을 수 없음`);
    }
    
    const featuredProperty = page.properties.featured || page.properties.Featured;
    const featured = featuredProperty?.type === 'checkbox' 
      ? featuredProperty.checkbox || false 
      : false;
    
    // 썸네일 이미지 URL 체크 (노션 페이지 커버 이미지가 있는 경우)
    let image = '';
    
    // 페이지 커버 이미지가 있는 경우
    if (page.cover) {
      if (page.cover.type === 'external') {
        image = page.cover.external.url;
      } else if (page.cover.type === 'file') {
        image = page.cover.file.url;
      }
    }
    
    // 이미지 속성이 직접 있는 경우
    const imageProperty = page.properties.image || page.properties.Image || page.properties.Cover || page.properties.Thumbnail;
    if (!image && imageProperty?.type === 'url') {
      image = imageProperty.url || '';
    } else if (!image && imageProperty?.type === 'files' && imageProperty.files.length > 0) {
      const file = imageProperty.files[0];
      if (file.type === 'external') {
        image = file.external.url;
      } else if (file.type === 'file') {
        image = file.file.url;
      }
    }
    
    notionLog.info(`📘 포스트 변환 완료: "${title}" (${category}), 조회수: ${views}, 이미지: ${image ? '있음' : '없음'}`);
    
    return {
      id: page.id,
      title,
      slug,
      excerpt,
      category,
      date,
      views,
      featured,
      image, // 썸네일 이미지 URL 추가
      content: "", // 컨텐츠는 별도로 가져와야 함
      author: { name: "Ryue" }, // 기본 작성자 정보 설정
      tags: [], // 기본 빈 태그 배열 설정
    };
  } catch (error) {
    notionLog.error("Error converting page to post:", error);
    notionLog.error("Problem page ID:", page.id);
    
    // 오류가 발생해도 기본 포스트 객체 반환
    return {
      id: page.id,
      title: "오류 발생한 게시물",
      slug: page.id,
      excerpt: "이 게시물을 변환하는 중 오류가 발생했습니다.",
      category: "daily-log" as CategoryId,
      date: new Date().toISOString().split('T')[0],
      views: 0,
      featured: false,
      content: "",
      author: { name: "Ryue" }, // 기본 작성자 정보 설정
      tags: [], // 기본 빈 태그 배열 설정
      image: "", // 이미지 속성 추가
    };
  }
}

// 블로그 포스트 속성 타입 정의
interface NotionPostProperties {
  Title: TitlePropertyItemObjectResponse;
  Excerpt: { rich_text: RichTextItemResponse[] };
  Category: SelectPropertyItemObjectResponse;
  Date: DatePropertyItemObjectResponse;
  Views: NumberPropertyItemObjectResponse;
  Slug: { rich_text: RichTextItemResponse[] };
  Published: { checkbox: boolean };
}

/**
 * Notion API와 데이터베이스 설정 유효성 검사
 * 애플리케이션 시작 시 호출되어 Notion 설정이 올바른지 확인
 * @returns Promise<boolean> 설정 유효성 여부
 */
export async function validateNotionConfig(): Promise<boolean> {
  notionLog.info('📘 Notion 설정 검증 시작...');
  try {
    const notionApiKey = process.env.NOTION_TOKEN;
    const notionDatabaseId = process.env.NOTION_DATABASE_ID;

    const configResult = {
      NOTION_TOKEN: {
        exists: !!notionApiKey,
        valid: notionApiKey && notionApiKey.length > 20,
        masked: notionApiKey ? `${notionApiKey.substring(0, 4)}...${notionApiKey.substring(notionApiKey.length - 4)}` : 'undefined'
      },
      NOTION_DATABASE_ID: {
        exists: !!notionDatabaseId,
        valid: notionDatabaseId && notionDatabaseId.length > 10,
        masked: notionDatabaseId || 'undefined'
      }
    };

    // 설정 유효성 검사
    if (!configResult.NOTION_TOKEN.exists || !configResult.NOTION_TOKEN.valid) {
      throw new Error('Notion API 키가 유효하지 않습니다.');
    }

    if (!configResult.NOTION_DATABASE_ID.exists || !configResult.NOTION_DATABASE_ID.valid) {
      throw new Error('Notion Database ID가 유효하지 않습니다.');
    }

    notionLog.info('✅ Notion 설정이 유효합니다:', {
      apiKey: configResult.NOTION_TOKEN.masked,
      databaseId: configResult.NOTION_DATABASE_ID.masked
    });

    return true;
  } catch (error) {
    notionLog.error('❌ Notion 설정 검증 중 오류 발생:', error);
    return false;
  }
}

/**
 * Notion API에 테스트 연결을 시도하여 API 키와 권한이 유효한지 확인
 */
async function testNotionConnection() {
  try {
    notionLog.info('📘 Notion API 연결 테스트 중...');
    
    const notionToken = process.env.NOTION_TOKEN;
    const databaseId = process.env.NOTION_DATABASE_ID;
    
    if (!notionToken || !databaseId) {
      notionLog.error('❌ API 키 또는 데이터베이스 ID가 없어 API 연결 테스트를 건너뜁니다.');
      return false;
    }
    
    // 데이터베이스 정보 조회 테스트
    const database = await notion.databases.retrieve({
      database_id: databaseId
    });
    
    // 데이터베이스 제목 접근 방식 수정
    let databaseTitle = 'Untitled';
    try {
      // @ts-ignore - Notion API 타입과의 호환성 문제
      if (database.title && database.title.length > 0) {
        // @ts-ignore
        databaseTitle = database.title[0].plain_text || 'Untitled';
      }
    } catch (e) {
      // 타입 오류 무시
    }
    
    notionLog.info(`✅ Notion API 연결 성공. 데이터베이스 "${databaseTitle}" 접근 가능`);
    
    return true;
  } catch (error) {
    notionLog.error('❌ Notion API 연결 테스트 실패:', error instanceof Error ? error.message : error);
    notionLog.error('❌ API 키와 데이터베이스 ID를 확인하세요.');
    return false;
  }
}

// Notion to Markdown 변환기 초기화
export const n2m = new NotionToMarkdown({ 
  notionClient: notion
});

// 블록 내용 가져오기
export async function getBlocks(blockId: string): Promise<(BlockObjectResponse | PartialBlockObjectResponse)[]> {
  try {
    notionLog.info(`📘 캐시 레이어를 통해 블록 ID "${blockId.substring(0, 8)}..."의 블록 가져오기 시작...`);
    return await getCachedBlocks(blockId);
  } catch (error) {
    notionLog.error("Error fetching blocks:", error);
    return [];
  }
}

// 블록을 HTML 컨텐츠로 변환
function blocksToHtml(blocks: (BlockObjectResponse | PartialBlockObjectResponse)[]): string {
  return blocks.map(block => {
    const { type } = block as BlockObjectResponse;
    
    if (!type) return '';
    
    // 타입 단언을 통해 안전하게 접근
    const blockWithType = block as any;
    const text = blockWithType[type]?.rich_text?.[0]?.plain_text || '';
    
    switch (type) {
      case 'paragraph':
        return text ? `<p>${text}</p>` : '<p></p>';
      case 'heading_1':
        return `<h1>${text}</h1>`;
      case 'heading_2':
        return `<h2>${text}</h2>`;
      case 'heading_3':
        return `<h3>${text}</h3>`;
      case 'bulleted_list_item':
        return `<li>${text}</li>`;
      case 'numbered_list_item':
        return `<li>${text}</li>`;
      case 'code':
        return `<pre><code>${text}</code></pre>`;
      case 'quote':
        return `<blockquote>${text}</blockquote>`;
      case 'divider':
        return '<hr/>';
      default:
        return '';
    }
  }).join('');
}

// 블록들을 HTML로 렌더링하는 함수
async function renderBlocks(blocks: BlockObjectResponse[]): Promise<{ html: string }> {
  try {
    notionLog.info(`📘 렌더링 시작: ${blocks.length}개 블록 처리 중...`);
    
    // 블록 타입별 카운트 (디버깅용)
    const blockTypeCount: Record<string, number> = {};
    const countBlockTypes = (blocks: any[]) => {
      blocks.forEach(block => {
        if (block.type) {
          blockTypeCount[block.type] = (blockTypeCount[block.type] || 0) + 1;
        }
        // 중첩된 블록도 카운트
        if (block.children && block.children.length > 0) {
          countBlockTypes(block.children);
        }
      });
    };
    
    countBlockTypes(blocks);
    notionLog.info('📘 블록 타입 통계:', blockTypeCount);
    
    // processBlocks 실행 전 로깅
    notionLog.info('📘 processBlocks 함수 호출 시작');
    const processStartTime = Date.now();
    
    const html = await processBlocks(blocks);
    
    const processEndTime = Date.now();
    notionLog.info(`📘 processBlocks 완료: 소요 시간 ${(processEndTime - processStartTime) / 1000}초`);
    notionLog.info(`📘 렌더링 완료: HTML 생성됨 (길이: ${html.length})`);
    
    // HTML이 비어있으면 경고
    if (html.trim() === '') {
      notionLog.warn('⚠️ 생성된 HTML이 비어있습니다. 디버깅 필요');
    }
    
    return { html };
  } catch (error) {
    notionLog.error('🔴 renderBlocks 오류:', error);
    return { html: '<div class="notion-error">컨텐츠를 불러올 수 없습니다.</div>' };
  }
}

/**
 * 페이지 컨텐츠 및 썸네일 URL 가져오기
 */
export async function getPageContentAndThumbnail(pageId: string): Promise<{ content: string, thumbnail: string, image: string }> {
  try {
    notionLog.info(`📘 캐시 레이어를 통해 페이지 ID "${pageId.substring(0, 8)}..."의 콘텐츠 가져오기 시작...`);
    return await getCachedPageContentAndThumbnail(pageId);
  } catch (error) {
    notionLog.error(`Error getting page content via cache layer:`, error);
    return { content: '', thumbnail: '', image: '' };
  }
}

// Add these helper functions before the renderRichText function
function escapeHTML(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function isEmoji(str: string): boolean {
  const regex = /[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u;
  return regex.test(str);
}

// 서식이 있는 텍스트 렌더링 - 색상 정보 포함
export function renderRichText(richText: RichTextItemResponse | RichTextItemResponse[] | undefined | null): string {
  // undefined, null 체크
  if (!richText) {
    notionLog.debug('renderRichText: richText가 undefined 또는 null입니다.');
    return "";
  }
  
  // 단일 항목인 경우 배열로 변환
  let richTextArray: RichTextItemResponse[] = [];
  
  if (Array.isArray(richText)) {
    richTextArray = richText;
  } else {
    // 단일 객체인 경우 배열로 변환
    richTextArray = [richText];
  }
  
  // 빈 배열 체크
  if (richTextArray.length === 0) {
    notionLog.debug('renderRichText: 변환할 리치 텍스트가 없습니다.');
    return "";
  }
  
  notionLog.debug(`Rendering ${richTextArray.length} rich text segments`);
  
  try {
    return richTextArray.map((item) => {
      if (!item) return ""; // 항목이 null 또는 undefined인 경우 처리
      
      let content = "";
      
      // Handle different types of rich text items
      if (item.type === "equation") {
        content = item.equation.expression;
      } else if (item.type === "text") {
        content = item.text.content;
        
        // 원본 내용 로깅 (디버깅용)
        if (content && (content.includes('\t') || content.match(/^ +/))) {
          notionLog.debug(`들여쓰기 감지: "${content.replace(/\n/g, '\\n').substring(0, 30)}..."`);
        }
        
        // HTML escape 먼저 수행 (emoji 제외)
        if (content && !isEmoji(content)) {
          content = escapeHTML(content);
        }
        
        // 모든 공백 처리 개선 (성능 향상을 위해 정규식 최소화)
        if (content) {
          // 1. 탭을 4개의 공백으로 변환
          content = content.replace(/\t/g, "    ");
          
          // 2. 줄 시작 부분의 공백 처리 (들여쓰기) - 각 줄마다 적용
          content = content.replace(/^( +)/gm, (match) => {
            return "&nbsp;".repeat(match.length);
          });
          
          // 3. 줄 중간의 연속된 공백 처리 (2개 이상 연속된 공백만 변환)
          content = content.replace(/( {2,})/g, (match) => {
            return " " + "&nbsp;".repeat(match.length - 1);
          });
          
          // 4. 줄바꿈 보존
          content = content.replace(/\n/g, "<br>");
        }
        
        // Handle annotations/styles
        const annotations = item.annotations;
        
        // Apply color styles - 개선된 색상 처리
        if (annotations.color && annotations.color !== "default") {
          const colorMap: Record<string, string> = {
            // 기본 색상
            "blue": "#2196f3",
            "blue_background": "#e3f2fd",
            "brown": "#795548",
            "brown_background": "#efebe9",
            "gray": "#9e9e9e",
            "gray_background": "#f5f5f5",
            "green": "#4caf50",
            "green_background": "#e8f5e9",
            "orange": "#ff9800",
            "orange_background": "#fff3e0",
            "pink": "#e91e63",
            "pink_background": "#fce4ec",
            "purple": "#9c27b0",
            "purple_background": "#f3e5f5",
            "red": "#f44336",
            "red_background": "#ffebee",
            "yellow": "#ffeb3b",
            "yellow_background": "#fffde7",
            // 추가 색상
            "default": "inherit",
            "black": "#000000",
            "white": "#ffffff",
          };
          
          const color = annotations.color;
          // 색상이 color_background 형식인지 확인
          if (color.endsWith("_background")) {
            const colorValue = colorMap[color] || color;
            content = `<span style="background-color: ${colorValue};">${content}</span>`;
          } else {
            const colorValue = colorMap[color] || color;
            content = `<span style="color: ${colorValue};">${content}</span>`;
          }
        }
        
        // Apply text styles
        if (annotations.bold) {
          content = `<strong>${content}</strong>`;
        }
        
        if (annotations.italic) {
          content = `<em>${content}</em>`;
        }
        
        if (annotations.strikethrough) {
          content = `<s>${content}</s>`;
        }
        
        if (annotations.underline) {
          content = `<u>${content}</u>`;
        }
        
        if (annotations.code) {
          content = `<code>${content}</code>`;
        }
        
        // Handle links
        if (item.href) {
          content = `<a href="${item.href}" target="_blank" rel="noopener noreferrer">${content}</a>`;
        }
      }
      
      return content;
    }).join("");
  } catch (error) {
    notionLog.error('🔴 renderRichText 오류:', error);
    return "";
  }
}

// 블록 자식들을 렌더링하는 함수
async function renderChildren(block: BlockObjectResponse): Promise<string> {
  if (!block || !block.has_children) return '';

  try {
    const response = await notion.blocks.children.list({
      block_id: block.id,
      page_size: 100, // 더 많은 자식 블록 가져오기
    });

    const blocks = response.results as BlockObjectResponse[];
    notionLog.info(`📘 블록 ${block.id}의 자식 ${blocks.length}개를 불러왔습니다.`);
    
    // 자식 블록 타입 로깅 (디버깅용)
    if (blocks.length > 0) {
      notionLog.debug(`자식 블록 타입: ${blocks.map(b => b.type).join(', ')}`);
    }
    
    let renderedChildren = '';
    
    // 현재의 리스트 타입을 추적
    let currentListType: string | null = null;
    let currentIndentLevel = 0;
    
    for (let i = 0; i < blocks.length; i++) {
      const childBlock = blocks[i];
      
      if ('type' in childBlock) {
        const blockType = childBlock.type;
        
        // 블록에 자식이 있는지 확인하고 재귀적으로 처리
        const hasNestedChildren = 'has_children' in childBlock && childBlock.has_children;
        
        // renderBlock이 BlockObjectResponse를 받도록 타입캐스팅
        const renderedBlock = await renderBlock(childBlock as BlockObjectResponse);
        let renderedContent = renderedBlock.renderedHtml;
        
        // 블록에 자식이 있으면 재귀적으로 처리하고 결과를 추가
        if (hasNestedChildren && !['toggle', 'callout'].includes(blockType)) {
          const nestedContent = await renderChildren(childBlock as BlockObjectResponse);
          
          // 자식 콘텐츠가 있으면 적절한 위치에 추가
          if (nestedContent.trim()) {
            // 리스트 항목의 경우 li 태그 내부에 추가
            if (blockType === 'bulleted_list_item' || blockType === 'numbered_list_item') {
              // li 태그 닫기 전에 중첩된 콘텐츠 추가
              renderedContent = renderedContent.replace('</li>', `${nestedContent}</li>`);
            } else {
              // 다른 블록 타입은 그냥 뒤에 추가
              renderedContent += nestedContent;
            }
          }
        }
        
        // 리스트 아이템 그룹화
        if (blockType === 'bulleted_list_item' || blockType === 'numbered_list_item') {
          const listType = blockType === 'bulleted_list_item' ? 'ul' : 'ol';
          
          // 리스트 타입이 바뀌거나 처음 시작하는 경우
          if (currentListType !== listType) {
            // 이전 리스트가 있으면 닫기
            if (currentListType) {
              renderedChildren += `</${currentListType}>\n`;
            }
            
            // 새 리스트 시작
            const listClass = listType === 'ul' ? 'list-disc' : 'list-decimal';
            currentListType = listType;
            renderedChildren += `<${listType} class="${listClass} ml-6 my-4">\n`;
          }
          
          // 리스트 아이템 추가
          renderedChildren += renderedContent;
        } else {
          // 리스트 아닌 블록을 만났을 때, 진행 중인 리스트가 있으면 닫기
          if (currentListType) {
            renderedChildren += `</${currentListType}>\n`;
            currentListType = null;
          }
          
          // 일반 블록 추가
          renderedChildren += renderedContent;
        }
      } else {
        notionLog.warn('타입 정보가 없는 블록:', childBlock);
      }
    }
    
    // 마지막에 열린 리스트가 있으면 닫기
    if (currentListType) {
      renderedChildren += `</${currentListType}>\n`;
    }
    
    return renderedChildren;
  } catch (error) {
    notionLog.error(`🔴 블록의 자식 불러오기 실패: ${block.id}`, error);
    return '<p class="text-red-500">콘텐츠를 불러오는데 실패했습니다.</p>';
  }
}

/**
 * 특정 ID로 게시물 가져오기
 */
export async function getPostById(id: string): Promise<BlogPost | null> {
  try {
    const page = await notion.pages.retrieve({ page_id: id }) as PageObjectResponse;
    const post = pageToPost(page);
    
    // 컨텐츠 및 썸네일 가져오기
    const { content, thumbnail } = await getPageContentAndThumbnail(id);
    post.content = content;
    
    // 페이지 속성에서 이미지가 없는 경우 컨텐츠에서 추출한 썸네일 사용
    if (!post.image && thumbnail) {
      post.image = thumbnail;
    }
    
    return post;
  } catch (error) {
    notionLog.error(`Error fetching post with ID ${id}:`, error);
    return null;
  }
}

/**
 * 특정 슬러그로 게시물 가져오기
 */
export async function getPostBySlug(slug: string): Promise<BlogPost | null> {
  try {
    notionLog.info(`📘 캐시 레이어를 통해 슬러그 "${slug}"로 포스트 가져오기 시작...`);
    return await getCachedPostBySlug(slug) as BlogPost | null;
  } catch (error) {
    notionLog.error(`Error fetching post with slug ${slug} via cache layer:`, error);
    return null;
  }
}

// 관련 포스트 가져오기
export const getRelatedPosts = cache(async (currentPostId: string, categoryName: string): Promise<BlogPost[]> => {
  notionLog.info(`📘 캐시 레이어를 통해 카테고리 "${categoryName}"의 관련 포스트 가져오기 시작...`);
  return await getCachedRelatedPosts(currentPostId, categoryName as CategoryId) as BlogPost[];
});

// 노션 페이지의 전체 블록 가져오기
export async function getPageBlocks(pageId: string) {
  try {
    notionLog.info(`📘 페이지 ${pageId}의 전체 블록 가져오기 시작`);
    const startTime = Date.now();
    
    // 모든 블록을 재귀적으로 가져오는 함수
    async function getAllPageBlocks(blockId: string, depth = 0): Promise<any[]> {
      const blocks: any[] = [];
      let cursor: string | undefined;
      let totalFetched = 0;
      let pageCount = 0;
      
      try {
        // 최대 30번의 페이지네이션으로 최대 3000개 블록 가져오기 시도
        for (let attempt = 0; attempt < 30; attempt++) {
          pageCount++;
          
          // API 요청 사이에 지연 추가 (속도 제한 방지)
          if (attempt > 0) {
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
          const { results, next_cursor } = await notion.blocks.children.list({
            block_id: blockId,
            start_cursor: cursor,
            page_size: 100, // 최대치인 100개씩 가져오기
          });
          
          if (results.length > 0) {
            blocks.push(...results);
            totalFetched += results.length;
            
            // 100개 단위로만 로그 출력하여 성능 향상
            if (totalFetched % 100 === 0 || pageCount === 1) {
              notionLog.info(`📘 페이지 ${blockId.substring(0, 8)}...에서 ${totalFetched}개 블록 추가 (깊이: ${depth}, 페이지: ${pageCount})`);
            }
          }
          
          // 다음 페이지가 없으면 중단
          if (!next_cursor) break;
          cursor = next_cursor;
        }
        
        // 하위 블록이 있는 블록만 필터링
        const blocksWithChildren = blocks.filter(block => block.has_children);
        
        if (blocksWithChildren.length > 0) {
          notionLog.info(`📘 하위 블록이 있는 블록 ${blocksWithChildren.length}개 발견 (깊이: ${depth})`);
        }
        
        // 하위 블록 가져오기를 병렬 처리하여 성능 향상
        const childBlockPromises = blocksWithChildren.map(async (block) => {
          // API 요청 사이에 짧은 지연 추가 (속도 제한 방지)
          await new Promise(resolve => setTimeout(resolve, 200));
          
          if (depth < 20) { // 깊이 제한 적용
            const childBlocks = await getAllPageBlocks(block.id, depth + 1);
            if (childBlocks.length > 0) {
              (block as any).children = childBlocks;
              notionLog.info(`📘 블록 ${block.id.substring(0, 8)}...에 ${childBlocks.length}개 하위 블록 추가 (깊이: ${depth + 1})`);
            }
          } else {
            notionLog.warn(`📙 최대 깊이 초과로 하위 블록 생략: ${block.id.substring(0, 8)}...`);
          }
          return block;
        });
        
        // 모든 하위 블록 요청 완료 대기
        await Promise.all(childBlockPromises);
        
        return blocks;
      } catch (error) {
        notionLog.error(`🔴 블록 가져오기 오류 (ID: ${blockId.substring(0, 8)}...):`, error);
        return blocks; // 오류가 발생해도 이미 가져온 블록은 반환
      }
    }
    
    // 실제 모든 블록 가져오기 실행
    const blocks = await getAllPageBlocks(pageId);
    const endTime = Date.now();
    const timeElapsed = (endTime - startTime) / 1000;
    
    notionLog.info(`📘 페이지 ${pageId.substring(0, 8)}...의 모든 블록 가져오기 완료: 총 ${blocks.length}개 (소요 시간: ${timeElapsed.toFixed(2)}초)`);
    
    // 하위 블록 수 계산 (디버깅용)
    let totalChildBlocks = 0;
    const countChildBlocks = (blocks: any[]) => {
      blocks.forEach(block => {
        if (block.children && block.children.length > 0) {
          totalChildBlocks += block.children.length;
          countChildBlocks(block.children);
        }
      });
    };
    
    countChildBlocks(blocks);
    notionLog.info(`📘 총 하위 블록 수: ${totalChildBlocks}개`);
    
    return blocks;
  } catch (error) {
    notionLog.error(`Error fetching page blocks: ${error}`);
    return [];
  }
}

// 노션 데이터베이스에서 페이지들 가져오기
export async function getDatabase() {
  const response = await notion.databases.query({
    database_id: databaseId as string,
    sorts: [
      {
        property: 'Created',
        direction: 'descending',
      },
    ],
  });
  
  return response.results;
}

// 페이지 ID로 특정 페이지 가져오기
export async function getPage(pageId: string) {
  const response = await notion.pages.retrieve({ page_id: pageId });
  return response;
}

/**
 * 데이터베이스 정보 가져오기 (디버깅용)
 */
export async function getDatabaseInfo() {
  try {
    if (!databaseId) {
      throw new Error("NOTION_DATABASE_ID 환경 변수가 설정되지 않았습니다.");
    }

    const database = await notion.databases.retrieve({
      database_id: databaseId as string,
    });
    
    // title이 있는 경우에는 타이틀 추출, 없으면 ID만 반환
    const dbTitle = 'title' in database ? 
      database.title.map(textObj => textObj.plain_text).join('') : 
      'Untitled Database';
    
    return {
      id: database.id,
      title: dbTitle,
      propertiesCount: Object.keys(database.properties).length,
      properties: database.properties,
    };
  } catch (error) {
    notionLog.error("Error fetching database info:", error);
    return null;
  }
}

// 모든 게시물 가져오기 (캐시 레이어 사용)
export async function getAllPosts(): Promise<BlogPost[]> {
  try {
    notionLog.info("📘 캐시 레이어를 통해 모든 포스트 가져오기 시작...");
    return await getCachedPosts() as BlogPost[];
  } catch (error) {
    notionLog.error("Error fetching posts via cache layer:", error);
    // 오류 상세 정보 로깅
    if (error instanceof Error) {
      notionLog.error("Error details:", error.stack);
    }
    return []; // 오류 발생 시 빈 배열 반환
  }
}

// HTML 문자열을 정리하는 함수 추가
function cleanHtml(html: string): string {
  // 일반적인 HTML 태그 패턴을 정리
  let cleaned = html;
  
  // 특정 닫는 태그 조합을 찾아서 제거
  const patterns = [
    /<\/figure><\/div><\/li><\/ul>/g,
    /<\/figure><\/div>/g,
    /<\/div><\/div>/g,
    /<\/li><\/ul>/g,
    /<\/ul><\/li>/g,
    /<\/div><\/li>/g,
    /<\/li><\/div>/g,
    /<\/div>(?!\s*<)/g,  // div 태그가 실제 태그가 아닌 텍스트로 표시된 경우 제거
    /(?<=<\/figure>)\s*<\/div>/g,  // figure 태그 뒤에 오는 불필요한 닫는 div 태그
    /&lt;\/div&gt;/g,  // HTML 이스케이프된 </div> 태그 제거
    /<p>\s*&lt;\/div&gt;\s*<\/p>/g  // <p></div></p> 형태의 태그 제거
  ];
  
  patterns.forEach(pattern => {
    // 실제 HTML 태그가 아닌 텍스트로 표시된 태그만 제거
    cleaned = cleaned.replace(pattern, '');
  });
  
  // 이미지 컨테이너 뒤에 오는 단독 닫는 div 태그 제거
  cleaned = cleaned.replace(/<div class="my-8 image-container">([\s\S]*?)<\/div>\s*<\/div>/g, '<div class="my-8 image-container">$1</div>');
  
  // figure 태그 뒤의 모든 불필요한 닫는 div 태그 제거 (더 강력한 버전)
  cleaned = cleaned.replace(/<figure class="my-8">([\s\S]*?)<\/figure>\s*(<\/div>)+/g, '<figure class="my-8">$1</figure>');
  
  // 텍스트로 표시된 </div> 태그를 직접 제거
  cleaned = cleaned.replace(/&lt;\/div&gt;/g, '');
  cleaned = cleaned.replace(/&amp;lt;\/div&amp;gt;/g, '');
  
  // 빈 p 태그 안의 </div> 텍스트 제거
  cleaned = cleaned.replace(/<p>\s*<\/div>\s*<\/p>/g, '');
  
  return cleaned;
}

// 블록 처리를 위한 함수
async function processBlocks(blocks: BlockObjectResponse[]): Promise<string> {
  let html = '';
  const imageUrls: string[] = [];
  
  try {
    notionLog.info(`📘 processBlocks: ${blocks.length}개 블록 처리 시작`);
    
    // 리스트 아이템 그룹화를 위한 변수
    let currentListType: string | null = null;
    let inList = false;
    
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      
      if (!block) {
        notionLog.warn('⚠️ Null 또는 undefined 블록 발견, 건너뜁니다.');
        continue;
      }
      
      try {
        notionLog.info(`📘 블록 처리 중 (#${i+1}/${blocks.length}): 타입=${block.type}, ID=${block.id.substring(0, 8)}...`);
        
        const blockType = block.type;
        const isListItem = ['bulleted_list_item', 'numbered_list_item'].includes(blockType);
        
        // 리스트 시작 또는 종료 처리
        if (isListItem) {
          const listType = blockType === 'bulleted_list_item' ? 'ul' : 'ol';
          
          // 새 리스트 시작
          if (!inList || currentListType !== listType) {
            // 이전 리스트가 있으면 닫음
            if (inList) {
              html += `</${currentListType}>\n`;
            }
            
            // 새 리스트 시작
            const listClass = listType === 'ul' ? 'list-disc' : 'list-decimal';
            html += `<${listType} class="${listClass} ml-6 my-4">\n`;
            currentListType = listType;
            inList = true;
          }
        } else if (inList) {
          // 리스트 종료
          html += `</${currentListType}>\n`;
          inList = false;
          currentListType = null;
        }
        
        // 블록 렌더링 및 이미지 URL 수집
        const result = await renderBlock(block as BlockObjectResponse);
        let renderedContent = result.renderedHtml;
        
        // 특별한 블록 타입에 따른 추가 처리
        if (blockType === 'image') {
          // 이미지 블록이 리스트 내부에 있으면 특별 처리
          if (inList) {
            // 현재 리스트를 닫고
            html += `</${currentListType}>\n`;
            // 이미지 추가
            html += renderedContent;
            // 리스트를 다시 시작
            const listClass = currentListType === 'ul' ? 'list-disc' : 'list-decimal';
            html += `<${currentListType} class="${listClass} ml-6 my-4">\n`;
          } else {
            html += renderedContent;
          }
        } else {
          // 리스트 아이템이 아닌 경우에만 HTML 추가
          if (!isListItem || !inList) {
            html += renderedContent;
          } else {
            // 리스트 아이템인 경우는 리스트 내부에 추가
            html += renderedContent;
          }
        }
        
        if (result.imageUrl) {
          imageUrls.push(result.imageUrl);
        }
        
        // 블록에 하위 블록이 있는 경우 재귀적으로 처리
        if ((block as any).children && (block as any).children.length > 0) {
          notionLog.info(`📘 하위 블록 처리 시작: ${(block as any).children.length}개 (부모: ${block.type})`);
          
          // 테이블과 토글은 이미 renderBlock 내부에서 자식 처리를 하므로 제외
          if (!['table', 'toggle', 'callout'].includes(block.type)) {
            const childrenHtml = await processBlocks((block as any).children);
            
            if (childrenHtml.trim()) {
              // 특정 블록 타입에 따라 하위 블록을 적절히 포맷팅
              if (isListItem) {
                // 리스트 아이템 내부에 하위 콘텐츠 추가
                // li 태그를 닫기 전에 중첩 콘텐츠 삽입
                const liCloseTagIndex = html.lastIndexOf('</li>');
                if (liCloseTagIndex !== -1) {
                  html = html.substring(0, liCloseTagIndex) + 
                         childrenHtml + 
                         html.substring(liCloseTagIndex);
                } else {
                  notionLog.warn(`⚠️ 리스트 아이템에서 </li> 태그를 찾을 수 없습니다. 자식 콘텐츠를 추가할 위치가 없습니다.`);
                  html += childrenHtml;
                }
              } else {
                // 다른 타입의 블록은 그냥 뒤에 추가
                html += childrenHtml;
              }
            }
          } else {
            notionLog.info(`📘 ${block.type} 블록의 하위 블록은 이미 renderBlock에서 처리됨`);
          }
        }
      } catch (blockError) {
        notionLog.error(`🔴 블록 처리 오류: ${block.id}`, blockError);
        html += `<p class="text-red-500">블록 로딩 오류: ${block.id}</p>`;
      }
    }
    
    // 처리가 끝났을 때 열려있는 리스트가 있으면 닫기
    if (inList && currentListType) {
      html += `</${currentListType}>\n`;
    }
    
    notionLog.info(`📘 processBlocks 완료: 총 ${blocks.length}개 블록 처리됨, HTML 길이: ${html.length}`);
    
    // HTML 정리 작업 수행
    const cleanedHtml = cleanHtml(html);
    notionLog.info(`📘 HTML 정리 완료: 정리 전 ${html.length} 글자 → 정리 후 ${cleanedHtml.length} 글자`);
    
    return cleanedHtml;
  } catch (error) {
    notionLog.error('🔴 processBlocks 처리 중 오류 발생:', error);
    return `<div class="notion-error">블록 처리 중 오류가 발생했습니다: ${error instanceof Error ? error.message : '알 수 없는 오류'}</div>`;
  }
}

// 단일 블록 렌더링 및 이미지 URL 추출
async function renderBlock(block: BlockObjectResponse): Promise<{ renderedHtml: string, imageUrl: string | null }> {
  if (!block) {
    notionLog.warn('Null or undefined block passed to renderBlock');
    return { renderedHtml: '', imageUrl: null };
  }
  
  try {
    let renderedHtml = '';
    let imageUrl: string | null = null;
    
    // 디버깅: 처리 중인 블록 타입 로그
    notionLog.debug(`블록 타입 처리: ${block.type}, ID: ${block.id.substring(0, 8)}...`);
    
    // 중첩된 블록 확인
    if ('has_children' in block && block.has_children) {
      notionLog.debug(`📘 중첩된 하위 블록 있음: ${block.id.substring(0, 8)}... (타입: ${block.type})`);
    }
    
    // 블록의 공통 색상 정보 추출
    const blockColor = (block as any)[block.type]?.color || 'default';
    let colorStyle = '';
    
    // 블록 색상 처리 개선
    if (blockColor && blockColor !== 'default') {
      const colorMap: Record<string, string> = {
        "blue": "#2196f3",
        "blue_background": "#e3f2fd",
        "brown": "#795548",
        "brown_background": "#efebe9",
        "gray": "#9e9e9e",
        "gray_background": "#f5f5f5",
        "green": "#4caf50",
        "green_background": "#e8f5e9",
        "orange": "#ff9800",
        "orange_background": "#fff3e0",
        "pink": "#e91e63",
        "pink_background": "#fce4ec",
        "purple": "#9c27b0",
        "purple_background": "#f3e5f5",
        "red": "#f44336",
        "red_background": "#ffebee",
        "yellow": "#ffeb3b",
        "yellow_background": "#fffde7",
        "black": "#000000",
        "white": "#ffffff",
      };
      
      if (blockColor.endsWith('_background')) {
        const bgColor = colorMap[blockColor] || blockColor;
        colorStyle = `background-color: ${bgColor}; padding: 0.5rem;`;
      } else {
        const textColor = colorMap[blockColor] || blockColor;
        colorStyle = `color: ${textColor};`;
      }
    }
    
    switch (block.type) {
      case 'paragraph':
        const paragraphContent = renderRichText(block.paragraph.rich_text);
        // pre-wrap 스타일을 추가하여 공백 및 줄바꿈 보존
        renderedHtml = `<p class="my-4 leading-relaxed text-gray-800 whitespace-pre-wrap" style="${colorStyle}">${paragraphContent || '<br>'}</p>`;
        break;
        
      case 'heading_1':
        const h1Content = renderRichText(block.heading_1.rich_text);
        renderedHtml = `<h1 class="text-3xl font-bold mt-8 mb-4 text-gray-900" style="${colorStyle}">${h1Content}</h1>`;
        break;
        
      case 'heading_2':
        const h2Content = renderRichText(block.heading_2.rich_text);
        renderedHtml = `<h2 class="text-2xl font-semibold mt-6 mb-3 text-gray-900" style="${colorStyle}">${h2Content}</h2>`;
        break;
        
      case 'heading_3':
        const h3Content = renderRichText(block.heading_3.rich_text);
        renderedHtml = `<h3 class="text-xl font-semibold mt-5 mb-2 text-gray-900" style="${colorStyle}">${h3Content}</h3>`;
        break;
        
      case 'bulleted_list_item':
        const bulletContent = renderRichText(block.bulleted_list_item.rich_text);
        renderedHtml = `<li class="ml-6 my-1.5 text-gray-800 whitespace-pre-wrap" style="${colorStyle}">${bulletContent}</li>`;
        break;
        
      case 'numbered_list_item':
        const numberedContent = renderRichText(block.numbered_list_item.rich_text);
        renderedHtml = `<li class="ml-6 my-1.5 text-gray-800 whitespace-pre-wrap" style="${colorStyle}">${numberedContent}</li>`;
        break;
        
      case 'quote':
        const quoteContent = renderRichText(block.quote.rich_text);
        renderedHtml = `<blockquote class="pl-4 border-l-4 border-gray-300 italic my-4 text-gray-700 whitespace-pre-wrap" style="${colorStyle}">${quoteContent}</blockquote>`;
        break;
        
      case 'code':
        // 코드 블록 내용 처리 개선
        const codeTexts: string[] = [];
        
        // 원본 텍스트 로그
        if (block.code.rich_text.length > 0) {
          notionLog.debug(`코드 블록 처리: 길이 ${block.code.rich_text.length}, 언어: ${block.code.language || 'plaintext'}`);
        }
        
        for (const richText of block.code.rich_text) {
          let codeText = richText.plain_text || "";
          
          // 공백과 들여쓰기 보존을 위한 처리
          if (codeText) {
            // HTML 이스케이프 적용
            codeText = codeText
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
            
            // 탭을 공백으로 변환 (HTML에서 탭 간격이 일정하지 않기 때문)
            codeText = codeText.replace(/\t/g, "    ");
            
            codeTexts.push(codeText);
          }
        }
        
        const codeContent = codeTexts.join('');
        const language = block.code.language || 'plaintext';
        
        // 코드 블록에서 white-space: pre 스타일 사용하여 모든 공백과 줄바꿈 보존
        renderedHtml = `<pre class="bg-gray-50 rounded-md p-4 my-4 overflow-x-auto whitespace-pre"><code class="language-${language} text-sm">${codeContent}</code></pre>`;
        break;
        
      case 'callout':
        const calloutContent = renderRichText(block.callout.rich_text);
        const emoji = block.callout.icon?.type === 'emoji' ? block.callout.icon.emoji : '';
        renderedHtml = `<div class="bg-gray-50 rounded-md p-4 my-4 flex">
          <div class="mr-3 text-xl">${emoji}</div>
          <div class="whitespace-pre-wrap">${calloutContent}</div>
        </div>`;
        break;
        
      case 'toggle':
        const toggleContent = renderRichText(block.toggle.rich_text);
        const childrenResults = await renderChildren(block);
        renderedHtml = `<details class="my-4">
          <summary class="cursor-pointer font-medium">${toggleContent}</summary>
          <div class="mt-2 text-gray-700 whitespace-pre-wrap">
            ${childrenResults}
          </div>
        </details>`;
        break;
        
      case 'image':
        // 이미지 URL 구성
        if (block.image.type === 'external') {
          imageUrl = block.image.external.url;
        } else if (block.image.type === 'file') {
          imageUrl = block.image.file.url;
        }
        
        // 전용 이미지 렌더링 함수 사용
        renderedHtml = renderImage(block);
        break;
        
      case 'divider':
        renderedHtml = `<hr class="my-6 border-gray-200" />`;
        break;
        
      case 'table':
        // 테이블 처리 추가
        if ('table' in block && block.table) {
          notionLog.debug(`테이블 처리: 너비 ${block.table.table_width || '정보 없음'}`);
          
          // 테이블 처리를 위한 자식 블록 가져오기 (rows)
          const tableRows = await renderChildren(block);
          
          // 테이블 렌더링
          renderedHtml = `<div class="my-6 overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200 border border-gray-200">
              ${tableRows}
            </table>
          </div>`;
        }
        break;
        
      case 'table_row':
        // 테이블 행 처리
        if ('table_row' in block && block.table_row) {
          const cells = block.table_row.cells || [];
          const rowHtml = cells.map(cell => {
            const cellContent = cell.map((text: any) => renderRichText(text)).join('');
            return `<td class="px-4 py-2 border border-gray-200">${cellContent || '&nbsp;'}</td>`;
          }).join('');
          
          renderedHtml = `<tr>${rowHtml}</tr>`;
        }
        break;
        
      default:
        notionLog.warn(`⚠️ 지원되지 않는 블록 타입: ${block.type}`, block);
        renderedHtml = `<div class="text-gray-400">지원되지 않는 블록 타입: ${block.type}</div>`;
    }
    
    return { renderedHtml, imageUrl };
  } catch (error) {
    notionLog.error(`🔴 블록 렌더링 오류: ${block.id}`, error);
    return { 
      renderedHtml: `<div class="text-red-500">오류: 블록을 렌더링할 수 없습니다. ${block.id}</div>`,
      imageUrl: null
    };
  }
}

// 이미지 블록 렌더링 함수
function renderImage(block: any): string {
  if (!block.image) return '';
  
  const imageUrl = block.image.file?.url || block.image.external?.url || '';
  const caption = block.image.caption?.length > 0 
    ? block.image.caption.map((text: any) => text.plain_text).join('') 
    : '';
  
  return `
    <figure class="my-8">
      <img 
        src="${imageUrl}" 
        alt="${caption || 'Image'}" 
        class="w-full rounded-lg"
      />
      ${caption ? `<figcaption class="text-center text-sm text-gray-500 mt-2">${caption}</figcaption>` : ''}
    </figure>
  `;
}

// 조회수 증가 함수
export async function increment(slug: string): Promise<number> {
  try {
    notionLog.info(`[Notion] Incrementing view count for slug: ${slug}`)
    
    // Find the page with the given slug
    const response = await notion.databases.query({
      database_id: databaseId as string,
      filter: {
        property: "Slug",
        rich_text: {
          equals: slug,
        },
      },
    })

    if (!response.results.length) {
      notionLog.error(`[Notion] No page found with slug: ${slug}`)
      return 0
    }

    // 첫 번째 결과 사용
    const page = response.results[0] as PageObjectResponse;
    
    // Get the current view count
    const viewsProperty = page.properties.Views || page.properties.views;
    
    if (!viewsProperty || viewsProperty.type !== 'number') {
      notionLog.error(`[Notion] No valid view count found for ${slug}`)
      return 0
    }
    
    const oldViews = viewsProperty.number || 0
    const newViews = oldViews + 1

    // Update the view count
    await notion.pages.update({
      page_id: page.id,
      properties: {
        Views: {
          number: newViews
        }
      }
    })

    notionLog.info(`[Notion] Successfully updated view count for ${slug} to ${newViews}`)
    return newViews
  } catch (error) {
    notionLog.error('[Notion] Error incrementing view count:', error)
    return 0
  }
} 